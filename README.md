<h1 align="center">Приветствую в первой части лабораторной работы</a></h1>
<h2 align="left">Давайте разберём новоизученное.</a></h2>
<p align = "left">
Для создания окна мы будем использовать библиотеку GLUT (точнее - в халявной её альтернативе freeglut) - в ней используются функции для приложений, написанных
под программный интерфейс OpenGL.</p>

<p align = "left">Начнём с точки входа.<br>
<strong>glutInit(&argc, argv)</strong> - инициализируем GLUT. Первый параметр представляет из себя указатель на количество аргументов в командной строке, а второй -
указатель на массив аргументов, где они, собственно, описаны. Параметры эти переданы через точку входа.</p>

<p align = "left"><b>glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA)</b> - настраиваем опции GLUT - устанавливаем для окна режим отображения информации: команда принимает константный
параметр или их коомбинацию с помощью побитового или <b>|</b>. В данном случае мы устанавливаем, что вывод в окно будет происходить с использованием двух буферов:
отрисовка будет происходить в фоновый буфер (область памяти, используемая для временного хранения данных ввода-вывода), в то время как другой буфер отображается.
Второй параметр - буфер цвета, использующийся для отображения графической информации при помощи 4 компонентов цвета - RGB (red, green, blue) и ALPHA (прозрачность).</p>

<p align = "left">Далее мы задаём параметры окна:<br>
<b>glutInitWindowSize(1024, 768);</b> - установили ширину и высоту окна (в пикселях)<br>
<b>glutInitWindowPosition(100, 100);</b> - задали положение создаваемого окна относительно верхнего левого угла экрана<br>
<b>glutCreateWindow("Tutorial 01");</b> - этой командой мы непосредственно создаём окно с указанным заголовком. Команда также возвращает уникальный идентификатор
созданного окна с типом integer. Впоследствии идентификатор может использоваться, например, при вызове команды <em>glutSetWindow</em>, которая делает окно с заданным
идентификатором текущим.</p>

<p align = "left">При работе с оконной системой большая часть действий с запущенной программой происходит через функции обратного вызова <em>(callback-функции)</em>. Нам нужно выводить
в окно графическую информацию (рендерить её), а для этого нужно связать окно с процедурами, которые, собственно, и будут отвечать за рендеринг.
<br>В GLUT их несколько, но мы используем эту:
<br><b>glutDisplayFunc(RenderSceneCB)</b> - функция принимает параметр - указатель на функцию, и делаёт её функцией обратного вызова. Впоследствии она будет отвечать за
рисование в окне. Т.е. при передаче контроля GLUT'у, он вызывает RenderSceneCB единожды всякий раз, когда нужно перерисовать окно.</p>

<p align = "left">Далее мы настраиваем состояние OpenGL, отвечающее за цвет очистки окна (каким будет цвет фона окна всякий раз после очистки):<br>
<b>glClearColor(1.0f, 0.0f, 1.0f, 0.0f)</b> - функция принимает параметры цветов и альфа-канала. 1.0 красного и 1.0 синего придадут окну розовый цвет.</p>

<p align = "left">Чтобы запустить нашу программу, нужно войти в <em>главный цикл GLUT</em>. Он обеспечивает обеспечивает взаимосвязь между операционной системой и теми функциями,
которые отвечают за окно, получают информацию от устройств ввода/вывода:<br>
<b>glutMainLoop()</b><br>
В этом цикле GLUT ждёт событий от оконной системы и передаёт их через функции обратного вызова, которые мы задали ранее.</p>

<p align = "left">Т.к. наша единственная функция обратного вызова - функция рендера RenderSceneCB, то вызывать он будет только её. Что же будет в этой функции?<br>
Функция <b>glClear(GL_COLOR_BUFFER_BIT)</b> - непосредственно очищает фон нашего окна при помощи заданного ранее командой glClearColor цвета, лежащего в буфере цвета.
Принимает параметр или побитовую коомбинацию из параметров, указывающих на буферы, которые подлежат очистке. Эти буферы: <em>GL_COLOR_BUFFER_BIT</em>,
<em>GL_DEPTH_BUFFER_BIT</em>, <em>GL_ACCUM_BUFFER_BIT</em> и <em>GL_STENCIL_BUFFER_BIT</em>.<br>
И функция <b>glutSwapBuffers()</b> - при использовании двойной буферизации меняет местами фоновый и передний буферы так, что задний слой становится передним.</p>

<p align = "left">Далее функция рендера завершается, как и завершается описание первой части лабораторной работы. Чтобы прочитать описание следующих частей, смените ветку репозитория
на lesson2 или lesson 3.</p>

<h1 align = "center">Приветствую в третьей части лабораторной работы</h1>
<p align = "left">Итак, в прошлой части мы смогли вывести точку на экран. Чтобы вывести на экран треугольник, нужно выполнить следующие действия.</p>

<p align = "left">В наш массив векторов добавляется три вектора-вершины, а не один - для каждого угла треугольника:<br>
  <b>glm::vec3 vecArrTrngl[3];<br>
	vecArrTrngl[0] = glm::vec3(-1.0f, -1.0f, 0.0f);<br>
	vecArrTrngl[1] = glm::vec3(1.0f, -1.0f, 0.0f);<br>
	vecArrTrngl[2] = glm::vec3(0.0f, 1.0f, 0.0f);</b></p>
  
  <p align = "left"> Ещё одно изменение нужно внести в функцию конвейера. Мы рисуем треугольник, поэтому наш GLenum mode параметр сменится с <em>GL_POINTS</em>
  на <em>GL_TRIANGLES</em>. Индекс всё так же начинается с 0, но количество объектов для отрисовки у нас теперь 3 - 3 вершины:<br>
  <b>glDrawArrays(GL_TRIANGLES, 0, 3)</b></p>
  
  <p align = "left"> Попытаюсь объяснить, почему не происходят изменения в других командах<br>
  <b>glGenBuffers(1, &VBO)</b> - мы всё так же создаём один объект - треугольник, и для него, как и для точки, нужен лишь один массив;<br>
  <b>glBindBuffer(GL_ARRAY_BUFFER, VBO)</b> - буффер всё также предназначен для хранения данных вершин;<br>
  <b>glBufferData(GL_ARRAY_BUFFER, sizeof(vecArrTrngl), vecArrTrngl, GL_STATIC_DRAW)</b> - первый параметр не меняется, второй - размер - будет увеличен, но принцип
  всё тот же. Третий - ясное дело - массив с вершинами. Параметр паттернов так же не меняется;<br>
  <b>glEnableVertexAttribArray(0)</b> - всё также используем лишь шейдерный атрибут координат;<br>
  <b>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0)</b> - используем тот же атрибут, координаты имеют те же 3 параметра того же типа, ненормализованные. Атрибуты
  расположены плотно и смещения между ними нет.</p>
  
  <p align = "left"> Вот так вот мы отрендерили и треугольник. Лабораторная работа завершена.</p>

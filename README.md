<h1><align = "center">Приветствую во второй части лабораторной работы</a></h1>
<p align = "left">Во второй части мы используем GLEW, которая упрощает запрос и загрузку расширений OpenGL. После инициализации он опрашивает все доступные на
платформе расширения, динамически загружая их и предоставляет простой доступ через единый заголовочный файл.<br>
  Также для использования векторов и математических операций, нужных для построения графики в OpenGL, мы используем библиотеку GLM.</p>
  
 <p align = "left">В первой части мы успешно вывели окно с заданным цветом фона. Взяв в основу этот код, продолжаем работу, чтобы вывести на экран точку.</p>
  
  <p align = "left">Для начала инициализируем GLEW:
  <br><b>GLenum res = glewInit()</b> - происходит инициализация GLEW путём выполнения команды glewInit(). Она возвращает результат инициализации - успешная она или нет.
  Этот результат мы помещаем в переменную res типа <em>GLenum</em>, который может содержать отладочные сообщения и другие unsigned int параметры.</p>
  
  <p align = "left">Далее проверим, успешная ли инициализация, сравнив сообщение в переменной res с сообщением успеха:<br>
<b>if (res != GLEW_OK)<br>
{<br>
	fprintf(stderr, "Error: '%s'\n", glewGetErrorString(res));<br>
	return 1;<br>
}</b></p>
  
  <p align = "left">После, при помощи библиотеки GLM мы инициализируем вектор с нулевыми координатами (тем самым задав точку) и заносим его в таблицу векторов:<br> 
  <b>glm::vec3 vec = glm::vec3(0.0f, 0.0f, 0.0f);<br>
  glm::vec3 vecArr[]{ vec };</b></p>
  
 <p align = "left"> Далее мы задаём указатель на буфер вершин. Он будет использоваться во всей программе, поэтому сделаем его глобальным:<br>
  <b>GLuint VBO;</b>
  <br><em>GLuint</em> - тип, схожий с типом unsigned int, но в зависимости от случая и платформы объекты данного типа могут иметь разные размеры.<br>
  <em>VBO - Vertex Buffer Object - объект буфера вершин</em> - это область буфера памяти, созданная в области памяти графической карты, которая используется для
  хранения различных типов информации атрибутов вершин, таких как координаты вершин, векторы вершин и данные цвета вершин. Во время рендеринга
  различные атрибутные данные вершин могут быть взяты непосредственно из VBO. Поскольку VBO находится в видеопамяти, а не в памяти, ему не нужно передавать данные
  из CPU, и эффективность обработки выше.</p>
  
 <p align = "left"> После мы генерируем массив, хранящий указатели на вершины, которые впоследствии будут в него внесены. Иначе говоря, создаём названия для вершин, которых
  в массиве пока нет:<br>
  <b>glGenBuffers(1, &VBO)</b> - первый параметр типа GLsizei (неотрицательное integer число для указания размера) - количество объектов, которые мы хотим
  сгенерировать (у нас один объект - вершина), второй - указатель на массив типа GLuints, где будут созданы объекты.</p>
  
  <p align = "left">Далее указываем, какую задачу будет выполнять наш буфер вершин, связываем буфер и его цель:<br>
  <b>glBindBuffer(GL_ARRAY_BUFFER, VBO)</b> - команда принимает назначение (target) буфера (в нашем случае - хранить вершины) - параметр типа GLenum
  и, соответственно, сам буфер.</p>
 
  <p align = "left">Связав буфер, наполняем его данными:<br>
  <b>glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW)</b> - команда принимает 4 параметра:
  <br>первый - задача буфера (та, с которой он связан);
<br>второй - размер данных, которые будут помещены в буфер (в байтах), типа GLsizeiptr;
<br>третий - адрес данных - массива вершин;
<br>четвёртый - типа GLenum usage - параметр, показывающий, будут ли использоваться патеррны хранения данных (в нашем случае STATIC - содержимое хранилища будет
изменено один раз и использовано много раз, DRAW - содержимое хранилища данных изменяется приложением и используется в качестве источника для команд рисования).</p>
  
  <p align = "left">Все параметры заданы, пора отправляться в функцию обратного вызова, т.е. запускать цикл GLUT'a.</p>
  
  <p align = "left">Осталось задать связь между программой и рендерингом. Что мы делаем:<br>  
  После очистки фона нам нужно включить атрибут позиции для нашей вершины, иначе мы не сможем использовать её в командах рисования:<br>
  <b>glEnableVertexAttribArray(0)</b><br>
  Параметры вершин, используемые в шейдерах, сопоставляются с их индексом, что позволяет создавать связи между данными в программе и названиями параметров в шейдерах,
  т.е. нам нужно включить индексацию атрибутов (координат, нормалей и тд.) вершин. Даже если мы сейчас не используем шейдеров, мы используем координаты. Индекс
  атрибута координат в буфере - это 0.</p>
  
  <p align = "left">Далее мы определяем общие данные для вершин, которые будут рендериться:<br>
 <b>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0)</b> - команда принимает 6 параметров:
 <br> первый - индекс атрибута, который мы хотим настроить (мы уже знаем, это 0 - позиция) (index тип GLuint);
 <br> второй - количество компонентов в атрибуте (у нас 3 - координаты x, y и z) (size тип GLuint);
 <br> третий - тип данных каждого компонента (type тип GLenum);
 <br> четвёртый - показывает, должны ли данные с фиксированной запятой быть нормализованы (normalized тип GLboolean). В нашем случае - нет;
 <br> пятый - задает смещение в байтах между последовательными общими атрибутами вершин (для нас шаг равен 0, т.е. считается, что общие атрибуты
 вершин плотно упакованы в массив) (stride тип GLsizei);
 <br> шестой - смещение начала данных в буфере. У нас буфер не имеет смещения и поэтому мы указываем 0.</p>
 
<p align = "left"> Ну и наконец мы запускаем конвейер - рисуем наши вершины:<br>
 <b>glDrawArrays(GL_POINTS, 0, 1)</b> - порядковая функция простой отрисовки. Первый параметр указывает, какие из примитивных объектов мы будем отрисовывать.
 Второй - индекс первой вершины для отрисовки. Третий - количество объектов для отрисовки.</p>
 
 <p align = "left">Когда отрисовка закончилось, необходимость в использовании атрибутов шейдеров пропадает и нужно их отключить:<br>
 <b>glDisableVertexAttribArray(0)</b> - параметр - соответственно индекс атрибута для отключения.</p>
 
 <p align = "left">После этого мы, как и в первой части работы, меняем местами буфер фона и буфер кадра.<br>
 Функция рендра завершается, работа окна описана.</p>
Конец объяснения второй части лабораторной. Небольшое объяснение третьей можно найти в readme файле ветки lesson3.
